var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Issues and PRs are always welcomed!","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To minimize the time  there are a few instructions on new issues and PRs","category":"page"},{"location":"contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Before opening an issue, please be sure that the problem has not been mentioned in any source:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Documentation\nMethod paper\nDiscussion\nOpen/Closed issues","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For bug reportings, please provide:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"A reproducible MWE (minimal working example)\nRunning environment (for example, call versioninfo() in Julia)\nCopied lines, shortcuts, captured videos, or any kind of error output","category":"page"},{"location":"contributing/#PRs","page":"Contributing","title":"PRs","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"New PRs should have:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"A few words in summary of new modifications\nAuto-test for new functions\nDocumentation for new features\nComments on complicated algorithms","category":"page"},{"location":"tutorial/basic/#Basic","page":"Basic","title":"Basic","text":"","category":"section"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"Before working on a simulation, it is recommanded to be familiar with dependencies of AstroNbodySim.jl","category":"page"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"The whole project is well documented. Use help? in REPL is the fastest way to get help if you forget the arguments or keywords of interfaces. For example,","category":"page"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"julia> using AstroIO\n\nhelp?> read_gadget2\nsearch: read_gadget2 read_gadget2_pos read_gadget2_jld\n\n  read_gadget2(filename::AbstractString, units, fileunits = uGadget2; kw...)\n\n  Return a Tuple of header and particle data in snapshot file.\n  units is supported by PhysicalParticles: uSI, uCGS, uAstro,\n  uGadget2, nothing. fileunits is the internal units in the file,\n  and will be converted to units while reading the file.\n\n  Keywords\n  ≡≡≡≡≡≡≡≡≡≡\n\n    •  acc::Bool = false : read acceleration data if exist\n\n    •  pot::Bool = false : read potential data if exist","category":"page"},{"location":"tutorial/basic/#Physical-vectors-and-particles","page":"Basic","title":"Physical vectors and particles","text":"","category":"section"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"# PhysicalParticles defines the basic physical vector and particle type\nusing PhysicalParticles\n\n# Set the default units to astrophysics. See `Unitful.preferunits` for more info\nastro()\n\n# using UnitfulAstro is necessary, if you are using astrophysical units\nusing UnitfulAstro\n\n# Define a physical vector\na = PVector(3.0u\"kpc\", 4.0u\"kpc\", 12.0u\"kpc\")\nb = PVector(1.0, 1.0, 1.0, u\"kpc\")\n\nc = PVector2D()\nd = PVector2D(0.0, 1.0)\n\n# Basic algebra\na * b\nc + d\n\nnorm(a)\nnormalize(a)\n\n# generate an array of physical vector\npoints = rand(PVector{Float64}, 5) * u\"kpc\"\np = randn_pvector2d(5)\n\nmean(p)\nPhysicalParticles.center(p)\nmedian(p)\n\n# Define particles\nparticles = [Star(uAstro, id = i) for i in 1:5]\n\n# Assign particle positions with array of points\nassign_particles(particles, :Pos, points)\n\n# average position\naverage(particles, :Pos)\n\n# average position by mass\nassign_particles(particles, :Mass, rand(5) * u\"Msun\")\naveragebymass(particles, :Pos)\n\n# StructArray is more efficient to manipulate field of struct in an array\nStructArray(particles)\n\n# Or construct directly\ns = StructArray(Star(uAstro, id = i) for i in 1:5)\n\n# StructArray is still supported by assign_particles, averagebymass, etc.\n# It is much more convenient to use dot operations\ns.Pos .= points\ns.Mass .= rand(5) * u\"Msun\"\ns","category":"page"},{"location":"tutorial/basic/#Generate-initial-conditions","page":"Basic","title":"Generate initial conditions","text":"","category":"section"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"using AstroIC\nconfig = PlummerStarCluster()\nparticles = generate(config)","category":"page"},{"location":"tutorial/basic/#Visualization","page":"Basic","title":"Visualization","text":"","category":"section"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"using AstroPlot\nfig = plot_makie(particles)\nfig","category":"page"},{"location":"tutorial/basic/#Snapshot-File-I/O","page":"Basic","title":"Snapshot File I/O","text":"","category":"section"},{"location":"tutorial/basic/","page":"Basic","title":"Basic","text":"using AstroIO\nif !isdir(\"output/\")\n    mkpath(\"output/\")\nend\n\nwrite_csv(\"output/basic.csv\", particles)\nwrite_jld(\"output/basic.jld2\", particles)\nwrite_gadget2(\"output/basic.gadget2\", particles) # This would generate a header automatically\n\n# generate a header and modify it\nheader = HeaderGadget2(particles)\nheader.time = 0.1   # Gyr\n\nwrite_gadget2(\"output/basicwithheader.gadget2\", header, particles, uGadget2) # write in Gadget2 units (default)\n\n# now load the files we had just written\nh, d = read_gadget2(\"output/basic.gadget2\", uAstro)\nd = read_jld(\"output/basic.jld2\")","category":"page"},{"location":"examples/05-plummer/#Plummer-Star-Cluster","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"","category":"section"},{"location":"examples/05-plummer/","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"In this example, we demonstrate how to:","category":"page"},{"location":"examples/05-plummer/","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"Simulate using DS gravity solver and Tree solver, both with adaptive and constant time-step\nGenerate a Plummer star cluster using AstroIC\nPlot Lagrangian radii and scale radius","category":"page"},{"location":"examples/05-plummer/","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"using AstroNbodySim, PhysicalParticles, Unitful, UnitfulAstro\nastro()\nmkpathIfNotExist(\"output\")\n\n# AstroIC supports initial condition sampling\nusing AstroIC\nusing PhysicalTrees\n\n## First define a config. Keywords are necessary since the config type is immutable\nconfig = PlummerStarCluster(\n    collection = STAR,\n    NumSamples = 1000,\n    VirialRadius = 0.010u\"kpc\",\n    TotalMass = 1.0e5u\"Msun\",\n    model = AstroIC.Newton(),\n)\n\n## Now generate particles. MaxRadius restricts the sampling region.\nparticles = generate(config, MaxRadius = 0.1u\"kpc\");\n\nTimeEnd = 0.1u\"Gyr\"\nTimeStep = 0.000004u\"Gyr\"\nTimeBetweenSnapshots = 0.0005u\"Gyr\"\n\n@info \"Testing multi-threading mode\"\nds = Simulation(\n    deepcopy(particles);\n    TimeEnd,\n    TimeBetweenSnapshots,\n    TimeStep,\n    OutputDir = \"output/Plummer-DirectSum\",\n);\n\nds_adapt = Simulation(\n    deepcopy(particles);\n    TimeEnd,\n    TimeBetweenSnapshots,\n    TimeStep = 0.0u\"Gyr\",\n    OutputDir = \"output/Plummer-DirectSumAdaptive\",\n);\n\nts = Simulation(\n    deepcopy(particles);\n    TimeEnd,\n    TimeBetweenSnapshots,\n    TimeStep,\n    GravitySolver = Tree(),\n    OutputDir = \"output/Plummer-Tree\",\n);\n\nts_adapt = Simulation(\n    deepcopy(particles);\n    TimeEnd,\n    TimeBetweenSnapshots,\n    TimeStep = 0.0u\"Gyr\",\n    GravitySolver = Tree(),\n    OutputDir = \"output/Plummer-TreeAdaptive\",\n);\n\nsuggest_softlen!(ds)\nsuggest_softlen!(ds_adapt)\nsuggest_softlen!(ts)\nsuggest_softlen!(ts_adapt)\n\nrun(ds)\nrun(ds_adapt)\nrun(ts)\nrun(ts_adapt)\n\n# Plots\nusing AstroIO\n\n@info \"Loading AstroPlot\"\nusing AstroPlot\nusing AstroPlot.ColorSchemes\nusing Colors\nusing GLMakie\nusing Printf\nusing FFMPEG\n\nfunction plotfigs(ds, ds_adapt, ts, ts_adapt)\n    @info \"Plotting radii\"\n    FigScale    = Figure(resolution = (800, 800))\n    FigLagrange = Figure(resolution = (800, 700))\n\n    colors = ColorSchemes.tab10.colors\n\n    AS1 = GLMakie.Axis(FigScale[1,1], title = \"Direct Sum const dt\")\n    AS2 = GLMakie.Axis(FigScale[1,2], title = \"Direct Sum adaptive dt\")\n    AS3 = GLMakie.Axis(FigScale[2,1], title = \"Tree const dt\")\n    AS4 = GLMakie.Axis(FigScale[2,2], title = \"Tree adaptive dt\")\n\n    AL1 = GLMakie.Axis(FigLagrange[1,1], title = \"Direct Sum const dt\")\n    AL2 = GLMakie.Axis(FigLagrange[1,2], title = \"Direct Sum adaptive dt\")\n    AL3 = GLMakie.Axis(FigLagrange[2,1], title = \"Tree const dt\")\n    AL4 = GLMakie.Axis(FigLagrange[2,2], title = \"Tree adaptive dt\")\n\n    plot_radii!(AS1, FigLagrange, AL1, ds.config.output.dir, \"snapshot_\", collect(0:200), \".gadget2\", gadget2(); colors, times = collect(0.0:0.0005:0.1) * u\"Gyr\", legend=false)\n    mv(\"radii.csv\", \"output/Plummer-DirectSum-radii.csv\", force = true)\n\n    plot_radii!(AS2, FigLagrange, AL2, ds_adapt.config.output.dir, \"snapshot_\", collect(0:200), \".gadget2\", gadget2(); colors, times = collect(0.0:0.0005:0.1) * u\"Gyr\", legend=false)\n    mv(\"radii.csv\", \"output/Plummer-DirectSumAdaptive-radii.csv\", force = true)\n\n    plot_radii!(AS3, FigLagrange, AL3, ts.config.output.dir, \"snapshot_\", collect(0:200), \".gadget2\", gadget2(); colors, times = collect(0.0:0.0005:0.1) * u\"Gyr\", legend=false)\n    mv(\"radii.csv\", \"output/Plummer-Tree-radii.csv\", force = true)\n\n    plot_radii!(AS4, FigLagrange, AL4, ts_adapt.config.output.dir, \"snapshot_\", collect(0:200), \".gadget2\", gadget2(); colors, times = collect(0.0:0.0005:0.1) * u\"Gyr\", legend=false)\n    mv(\"radii.csv\", \"output/Plummer-TreeAdaptive-radii.csv\", force = true)\n\n    colsize!(FigLagrange.layout, 1, Relative(0.47))\n    colsize!(FigLagrange.layout, 2, Relative(0.47))\n    rowsize!(FigLagrange.layout, 1, Relative(0.5))\n    rowsize!(FigLagrange.layout, 2, Relative(0.5))\n\n    supertitle = Label(FigScale[0,:], \"Scale Radius\")\n    Makie.save(\"output/Plummer-ScaleRadius.png\", FigScale)\n\n    supertitle = Label(FigLagrange[0,:], \"Lagrange Radii\")\n    Makie.save(\"output/Plummer-LagrangianRadii.png\", FigLagrange)\nend\n\nplotfigs(ds, ds_adapt, ts, ts_adapt)","category":"page"},{"location":"examples/05-plummer/","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"(Image: Lagrangian Radii)","category":"page"},{"location":"examples/05-plummer/","page":"05 Plummer Star Cluster","title":"05 Plummer Star Cluster","text":"(Image: Scale Radius)","category":"page"},{"location":"lib/Types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/Types/","page":"Types","title":"Types","text":"Pages = [\"Types.md\"]","category":"page"},{"location":"lib/Types/","page":"Types","title":"Types","text":"Simulation\nSimConfig\nLogInfo\nStreamInfo\nTimeInfo\nOutputInfo\nPhysicsInfo\nVisualizationInfo\nTreeSimConfig\nOctreeData\nBuffer","category":"page"},{"location":"lib/Types/#AstroNbodySim.Simulation","page":"Types","title":"AstroNbodySim.Simulation","text":"struct Simulation{D}\n\nconfig::Any\nid::Pair{Int64, Int64}\npids::Vector{Int64}\nsimdata::Any\ntimeinfo::Any\n::TimeInfo\noutputinfo::Any\n::OutputInfo\nloginfo::Any\n::LogInfo\nphysics::Any\n::PhysicsInfo\nstream::Any\n::StreamInfo\nvisinfo::Any\n::VisualizationInfo\nbuffer::Any\n::Buffer\nbgforce::Vector{Function}\nbgpotential::Vector{Function}\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.SimConfig","page":"Types","title":"AstroNbodySim.SimConfig","text":"struct SimConfig{F, U}\n\nname::String\nauthor::String\ndaytime::Dates.DateTime\nfloattype::Any\nNumeric type of float numbers\nunits::Any\nPrefered units in simulation. Default is uAstro. See PhysicalParticles: uAstro, uSI, uGadget2, uCGS. To run without units, use nothing\nZeroValues::Any\nZeroValue. Pre-constructed zero values for different types to simplify function arguments\nconstants::Any\nConstant. Physical constants\nloggingmode::Any\nChoose how to display status of simulation. Supported: NormalMode, ProgressMode, SilentMode. Default is ProgressMode displaying progress bars\ntime::Any\nTimeConfig\noutput::Any\nOutputConfig\nsolver::Any\nSolverConfig\ngrav::Any\nGravityConfig\ndevice::Any\nDeviceConfig\n\nExamples\n\nSimConfig(; GravitySolver = Tree())\nSimConfig(; device = GPU(), TimeStep = 1.0e-5u\"Gyr\")\nSimConfig(; units = uGadget2)\nSimConfig(; units = nothing, ForceSofteningTable = [0.01 for i in 1:6])\nSimConfig(; TimeEnd = 1.0u\"Gyr\", OutputDir = \"Test/Dir\")\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.StreamInfo","page":"Types","title":"AstroNbodySim.StreamInfo","text":"mutable struct StreamInfo\n\nloggingio::IOStream\ntimerio::IOStream\nanalyserio::IOStream\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.TimeInfo","page":"Types","title":"AstroNbodySim.TimeInfo","text":"mutable struct TimeInfo{T<:Number, I<:Integer}\n\ndt::Number\nTime interval between neighbor time steps\nsystem_time_int::Integer\nsystem_time_float::Number\nlast_system_time_int::Integer\nlast_system_time_float::Number\nnext_output_time_int::Integer\nnext_output_time_float::Number\nredshift::Float64\nscalefactor::Float64\nmin_endstep::Integer\nstepcount::Integer\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.OutputInfo","page":"Types","title":"AstroNbodySim.OutputInfo","text":"mutable struct OutputInfo\n\nsnapshotcount::Int64\nsyncflag::Bool\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.PhysicsInfo","page":"Types","title":"AstroNbodySim.PhysicsInfo","text":"mutable struct PhysicsInfo\n\nNumForceUpdateSinceLast::Int64\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.VisualizationInfo","page":"Types","title":"AstroNbodySim.VisualizationInfo","text":"mutable struct VisualizationInfo\n\nprogress::ProgressMeter.Progress\nPlotData::Any\nresolution::Any\nfig::Any\nRealtime::Bool\nRenderTime::Float64\nlast_plot_time::Float64\nxlims::Any\nylims::Any\nzlims::Any\nmarkersize::Float64\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.TreeSimConfig","page":"Types","title":"AstroNbodySim.TreeSimConfig","text":"struct TreeSimConfig\n\nControls accuracy of tree method\n\nTreeOpenAngle::Float64\nIf the view angle of tree node that relative to the sink point is too large, open this node. In radian unit. Default is 0.1\nErrTolAcc::Float64\nWhile opening the tree node, take the last acceleration into account. Improves accuracy at high redshift cosmology. Default is 0.025\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#Trait-types","page":"Types","title":"Trait types","text":"","category":"section"},{"location":"lib/Types/","page":"Types","title":"Types","text":"DirectSum\nTree\nFDM\nFFT\nML\nSPH\nMHD\nFEM\nFVM\nGravityModel\nNewton\nMOND1983Milgrom\nQUMOND\nLoggingMode\nNormalMode\nProgressMode\nSilentMode\nTimeIntegration\nEuler\nLeapfrog\nGPUAlgorithm\nAllPairs\nTiled\nOutboundLimiter\nDelete\nDS\nCoarseMesh","category":"page"},{"location":"lib/Types/#AstroNbodySim.DirectSum","page":"Types","title":"AstroNbodySim.DirectSum","text":"Direct Summation Method\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.Tree","page":"Types","title":"AstroNbodySim.Tree","text":"Peano-Hilbert Space Filling Octree Method\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.FDM","page":"Types","title":"AstroNbodySim.FDM","text":"Finite Differencing Method\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.FFT","page":"Types","title":"AstroNbodySim.FFT","text":"Fast Fourier Transform\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.ML","page":"Types","title":"AstroNbodySim.ML","text":"Machine Learning\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.SPH","page":"Types","title":"AstroNbodySim.SPH","text":"Smoothed Particle Hydrodynamics\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.MHD","page":"Types","title":"AstroNbodySim.MHD","text":"Magnetohydrodynamics\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.FEM","page":"Types","title":"AstroNbodySim.FEM","text":"Finite Element Method\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.FVM","page":"Types","title":"AstroNbodySim.FVM","text":"Finite Volume Method\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.GravityModel","page":"Types","title":"AstroNbodySim.GravityModel","text":"Gravity model. Supported: Newton, MOND1983Milgrom, QUMOND\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.Newton","page":"Types","title":"AstroNbodySim.Newton","text":"Traditional Newtonian gravity\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.MOND1983Milgrom","page":"Types","title":"AstroNbodySim.MOND1983Milgrom","text":"Milgrom 1983 formula of MOND\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.Euler","page":"Types","title":"AstroNbodySim.Euler","text":"1st-order explicit Euler time integration\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.Leapfrog","page":"Types","title":"AstroNbodySim.Leapfrog","text":"Leapfrog time integration\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.OutboundLimiter","page":"Types","title":"AstroNbodySim.OutboundLimiter","text":"`::OutboundLimiter`. Choose how to handle particles out of the non-periodic simulation box.\nSupported:\n    - `Delete`: delete outbound particles\n    - `DS`: use direct summation method to compute forces \n    - `CoarseMesh`: Construct a coarse mesh to overlap all particles\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.Delete","page":"Types","title":"AstroNbodySim.Delete","text":"Delete outbound particles if they run out of the non-periodic simulation box\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.DS","page":"Types","title":"AstroNbodySim.DS","text":"Compute forces using direct summation method if the particles run out of the non-periodic simulation box\n\n\n\n\n\n","category":"type"},{"location":"lib/Types/#AstroNbodySim.CoarseMesh","page":"Types","title":"AstroNbodySim.CoarseMesh","text":"Construct a coarse mesh to overlap all particles for non-periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"examples/02-autodiff-bg/#Autodiff-on-background-potential-field","page":"02 Autodiff on background potential field","title":"02 Autodiff on background potential field","text":"","category":"section"},{"location":"examples/02-autodiff-bg/","page":"02 Autodiff on background potential field","title":"02 Autodiff on background potential field","text":"using PhysicalParticles, UnitfulAstro\nusing AstroNbodySim\nusing CSV, DataFrames\nusing GLMakie\n\nusing Zygote\n\nastro()\nmkpathIfNotExist(\"output\")\n\np1x(sim::Simulation) = find_particle(sim, 1).Pos.x\np1y(sim::Simulation) = find_particle(sim, 1).Pos.y\n\nanalysers = Dict(\n    \"x\" => p1x,\n    \"y\" => p1y,\n)\n\nG = Constant(uAstro).G\n\n# Define the potential field of Plummer model\nM = 1.0e6u\"Msun\"\nb = 0.01u\"kpc\"\n\nphi(p::PVector) = -(G*M)/sqrt(p*p+b*b)\n\n# Autodiff by Zygote\nacc(p::PVector) = -1.0*PVector(gradient(phi, p)[1]...)\nacc(p::AbstractParticle) = acc(p.Pos)\n\nbgforce = Function[acc]\n\nR = 0.05u\"kpc\"\nvel = sqrt(G*M/R)\nT = 2*pi*sqrt(R^3 / G / M)\nTimeEnd = 4.5*T\n\ndata = StructArray([Star(uAstro, id = 1)])\ndata.Pos[1] = PVector(            R, 0.0u\"kpc\", 0.0u\"kpc\")\ndata.Vel[1] = PVector(0.0u\"kpc/Gyr\",   0.7*vel, 0.0u\"kpc/Gyr\")\n\n\nsim = Simulation(deepcopy(data);\n    pids = [1],\n    bgforce,\n    analysers,\n    TimeEnd,\n    TimeBetweenSnapshots = TimeEnd,\n    OutputDir = \"AutodiffBackground\"\n)\nrun(sim)\n\n# Plot\ntitle = \"Orbit in potential field of Plummer model\"\ndf = DataFrame(CSV.File(joinpath(sim.config.output.dir, \"analysis.csv\")))\nfig = Figure(resolution = (800,800))\naxis = GLMakie.Axis(fig[1,1]; title, xlabel = \"x [kpc]\", ylabel = \"y [kpc]\")\naxis.autolimitaspect = 1\nMakie.lines!(axis, df.x, df.y)\nMakie.save(joinpath(\"output/AutodiffBackground.png\"), fig)","category":"page"},{"location":"examples/02-autodiff-bg/","page":"02 Autodiff on background potential field","title":"02 Autodiff on background potential field","text":"(Image: Orbit in potential field of Plummer model)","category":"page"},{"location":"examples/04-Bigfloat/#BigFloat","page":"04 BigFloat","title":"04 BigFloat","text":"","category":"section"},{"location":"examples/04-Bigfloat/","page":"04 BigFloat","title":"04 BigFloat","text":"In this example, we demonstrate how to compute with BigFloat.","category":"page"},{"location":"examples/04-Bigfloat/","page":"04 BigFloat","title":"04 BigFloat","text":"# The basic setup is same with example-01\nusing AstroIO\nusing AstroPlot\nusing AstroPlot.ColorSchemes\nusing Colors\nusing CSV, DataFrames\n\nusing Plots\npyplot() # Need PyPlot to be installed\n\nusing AstroNbodySim\nusing PhysicalParticles\nusing Unitful, UnitfulAstro\nastro()\nmkpathIfNotExist(\"output\")\n\n\nastro()\nG = Constant(BigFloat, uAstro).G\n\nmass = BigFloat(\"1.0e10\")u\"Msun\"\nD = BigFloat(\"2.0\")u\"kpc\"\n\nbinary_orbit_period(mass, D) = 2 * pi * sqrt(0.5 * D^3 / G / mass)\n\nbinary_rot_vel(mass, D) = sqrt(G * mass / D / 2.0)\n\nvel = binary_rot_vel(mass, D)\nT = binary_orbit_period(mass, D)\n\n@info \"Estimated Period: $(T)\"\n@info \"Estimated Rotation Vel: $(vel)\"\n\ndata = StructArray(Star(BigFloat, Int, uAstro, id = i) for i in 1:2)\ndata.Pos[1] = PVector(+0.5*BigFloat(D), BigFloat(0.0)*u\"kpc\", BigFloat(0.0)*u\"kpc\")\ndata.Pos[2] = PVector(-0.5*BigFloat(D), BigFloat(0.0)*u\"kpc\", BigFloat(0.0)*u\"kpc\")\ndata.Vel[1] = PVector(BigFloat(0.0)*u\"kpc/Gyr\", +BigFloat(vel), BigFloat(0.0)*u\"kpc/Gyr\")\ndata.Vel[2] = PVector(BigFloat(0.0)*u\"kpc/Gyr\", -BigFloat(vel), BigFloat(0.0)*u\"kpc/Gyr\")\ndata.Mass .= mass\n\nTimeEnd = 0.030u\"Gyr\"\nTimeStep = 0.00002u\"Gyr\"\nTimeBetweenSnapshots = 0.0005u\"Gyr\"\n\nbig = Simulation(\n    deepcopy(data);\n    TimeEnd,\n    TimeBetweenSnapshots, \n    TimeStep,\n    OutputDir = \"output/BigFloat\",\n    constants = Constant(BigFloat, uAstro),\n    ZeroValues = ZeroValue(BigFloat, uAstro),\n    ForceSofteningTable = [BigFloat(\"1.0e-4\")*u\"kpc\" for i in 1:6],\n)\ncompute_force(big)\ncompute_potential(big)\n\ndisplay(big.simdata.Acc)\ndisplay(big.simdata.Potential)\n\nrun(big)\ndisplay(big.simdata.Pos)","category":"page"},{"location":"ChineseTutorial/basic/#基础使用","page":"基础使用","title":"基础使用","text":"","category":"section"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"在着手模拟之前，建议首先熟悉 AstroNbodySim.jl 的依赖包","category":"page"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"整个项目有较为完善的注释，在开发和使用过程中如果不熟悉接口的参数和关键字，可以在 REPL 中使用 help?> 快速获得帮助，比如：","category":"page"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"julia> using AstroIO\n\nhelp?> read_gadget2\nsearch: read_gadget2 read_gadget2_pos read_gadget2_jld\n\n  read_gadget2(filename::AbstractString, units, fileunits = uGadget2; kw...)\n\n  Return a Tuple of header and particle data in snapshot file.\n  units is supported by PhysicalParticles: uSI, uCGS, uAstro,\n  uGadget2, nothing. fileunits is the internal units in the file,\n  and will be converted to units while reading the file.\n\n  Keywords\n  ≡≡≡≡≡≡≡≡≡≡\n\n    •  acc::Bool = false : read acceleration data if exist\n\n    •  pot::Bool = false : read potential data if exist","category":"page"},{"location":"ChineseTutorial/basic/#带单位的矢量和粒子类型","page":"基础使用","title":"带单位的矢量和粒子类型","text":"","category":"section"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"# PhysicalParticles 定义了矢量和粒子类型\nusing PhysicalParticles\n\n# 将默认（换算）单位设置为天体物理单位\nastro()\n\n# using UnitfulAstro 十分必要，如果在使用天体物理单位的话\nusing UnitfulAstro\n\n# 定义带单位的矢量\na = PVector(3.0u\"kpc\", 4.0u\"kpc\", 12.0u\"kpc\")\nb = PVector(1.0, 1.0, 1.0, u\"kpc\")\n\nc = PVector2D()\nd = PVector2D(0.0, 1.0)\n\n# 基本矢量运算\na * b\nc + d\n\nnorm(a)\nnormalize(a)\n\n# 矢量的数组\npoints = rand(PVector{Float64}, 5) * u\"kpc\"\np = randn_pvector2d(5)\n\nmean(p)\nPhysicalParticles.center(p)\nmedian(p)\n\n# 定义粒子\nparticles = [Star(uAstro, id = i) for i in 1:5]\n\n# 逐一修改粒子坐标\nassign_particles(particles, :Pos, points)\n\n# 平均坐标\naverage(particles, :Pos)\n\n# 质心坐标\nassign_particles(particles, :Mass, rand(5) * u\"Msun\")\naveragebymass(particles, :Pos)\n\n# StructArray 可以更加高效地修改粒子数据\nStructArray(particles)\n\n# 可以直接创建 StructArray\ns = StructArray(Star(uAstro, id = i) for i in 1:5)\n\n# StructArray 同样支持其他函数，比如 assign_particles, averagebymass 等\n# It is much more convenient to use dot operations\ns.Pos .= points\ns.Mass .= rand(5) * u\"Msun\"\ns","category":"page"},{"location":"ChineseTutorial/basic/#生成初始条件","page":"基础使用","title":"生成初始条件","text":"","category":"section"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"using AstroIC\nconfig = PlummerStarCluster()\nparticles = generate(config)","category":"page"},{"location":"ChineseTutorial/basic/#可视化","page":"基础使用","title":"可视化","text":"","category":"section"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"using AstroPlot\nplot_makie(particles)","category":"page"},{"location":"ChineseTutorial/basic/#Snapshot-文件读写","page":"基础使用","title":"Snapshot 文件读写","text":"","category":"section"},{"location":"ChineseTutorial/basic/","page":"基础使用","title":"基础使用","text":"using AstroIO\nif !isdir(\"output/\")\n    mkpath(\"output/\")\nend\n\nwrite_csv(\"output/basic.csv\", particles)\nwrite_jld(\"output/basic.jld2\", particles)\nwrite_gadget2(\"output/basic.gadget2\", particles) # This would generate a header automatically\n\n# 可以从粒子数据生成 Gadget2 header\nheader = HeaderGadget2(particles)\nheader.time = 0.1   # Gyr\n\nwrite_gadget2(\"output/basicwithheader.gadget2\", header, particles, uGadget2) # write in Gadget2 units (default)\n\n# 读取刚刚写入的文件\nh, d = read_gadget2(\"output/basic.gadget2\", uAstro)\nd = read_jld(\"output/basic.jld2\")","category":"page"},{"location":"ChineseManual/DirectSum/#DirectSum-直接相加法","page":"DirectSum 直接相加法","title":"DirectSum 直接相加法","text":"","category":"section"},{"location":"examples/03-Measurements/#Measurements:-Uncertainty-propagation","page":"03 Measurements: Uncertainty propagation","title":"03 Measurements: Uncertainty propagation","text":"","category":"section"},{"location":"examples/03-Measurements/","page":"03 Measurements: Uncertainty propagation","title":"03 Measurements: Uncertainty propagation","text":"In this example, we demonstrate how to:","category":"page"},{"location":"examples/03-Measurements/","page":"03 Measurements: Uncertainty propagation","title":"03 Measurements: Uncertainty propagation","text":"Compute with Measurement\nPropagate uncertainties from initial conditions\nPlot orbit uncertainties","category":"page"},{"location":"examples/03-Measurements/","page":"03 Measurements: Uncertainty propagation","title":"03 Measurements: Uncertainty propagation","text":"# The basic setup is same with example-01\nusing AstroIO\nusing AstroPlot\nusing AstroPlot.ColorSchemes\nusing Colors\nusing CSV, DataFrames\n\nusing Plots\npyplot() # Need PyPlot to be installed\n\nusing AstroNbodySim\nusing PhysicalParticles\nusing Unitful, UnitfulAstro\nastro()\nmkpathIfNotExist(\"output\")\n\np1x(sim::Simulation) = find_particle(sim, 1).Pos.x\np1y(sim::Simulation) = find_particle(sim, 1).Pos.y\n\nanalysers = Dict(\n    \"x\" => p1x,\n    \"y\" => p1y,\n)\n\n\nusing Measurements\nG = Constant(Measurement, uAstro).G\n\nmass = measurement(1.0e8u\"Msun\", 1.0e6u\"Msun\")\nR = measurement(1.0u\"kpc\", 0.01u\"kpc\")\n\ne = 0.9\n\nvel = sqrt((1.0-e)*G*mass/R)\n@info \"Velocity at ap: $(vel)\"\n\na = ellipticSemiMajor(G, mass, R, vel)\n@info \"Length of semi-major axis: $(a)\"\n\nT = ellipticPeriod(G, mass, a)\n@info \"Period of elliptical orbit: $(T)\"\n\n# Define the two particles\ndata = StructArray(Star(Measurement, Int, uAstro, id = i) for i in 1:2)\ndata.Pos[1] = PVector(R, measurement(0.0u\"kpc\"), measurement(0.0u\"kpc\"))\ndata.Vel[1] = PVector(measurement(0.0u\"kpc/Gyr\"), +vel, measurement(0.0u\"kpc/Gyr\"))\n\ndata.Mass[2] = mass\n\n\nTimeEnd = Measurements.value(T) * 0.95\nTimeBetweenSnapshots = TimeEnd\n\nm = Simulation(\n    deepcopy(data);\n    analysers,\n    TimeEnd,\n    TimeBetweenSnapshots,\n    OutputDir = \"output/Measurements\",\n    constants = Constant(Measurement, uAstro),\n    ZeroValues = ZeroValue(Measurement, uAstro),\n    ForceSofteningTable = measurement.([1.0e-4u\"kpc\" for i in 1:6]),\n)\nrun(m)\n\n# plot the orbit with uncertainties\nfunction plot_orbit_with_uncertainties(sim::Simulation, title::String;\n    resolution = (800,450),\n    xlabel = \"x [kpc]\", ylabel = \"y [kpc]\",\n)\n    df = DataFrame(CSV.File(joinpath(sim.config.output.dir, \"analysis.csv\")))\n    xm = measurement.(df.x)\n    ym = measurement.(df.y)\n\n    x = Measurements.value.(xm)\n    y = Measurements.value.(ym)\n\n    # find the flip one, to avoid wrong color of covered error bars\n    s = sign(y[1])\n    flip = 0\n    for i in eachindex(y)\n        if s != sign(y[i])\n            flip = i\n            break\n        end\n    end\n\n    xerror = Measurements.uncertainty.(xm)\n    yerror = Measurements.uncertainty.(ym)\n\n    p = Plots.plot(x[1:flip], y[1:flip];\n        ribbon = yerror[1:flip], legend=nothing,\n        xlabel, ylabel, title,\n        size = resolution,\n        aspect_ratio = 1,\n    )\n    Plots.plot!(p, x[flip+1:end], y[flip+1:end]; ribbon = yerror[flip+1:end])\n    Plots.plot!(p, [1.0; 0.92], [0.1,0.15],arrow=(2,1.0))\n    savefig(p, \"output/\" * title * \".png\")\n    return DataFrame(time = df.time, x = xm, y = ym)\nend\nplot_orbit_with_uncertainties(m, \"Uncertainty of elliptic orbit\", resolution = (800,450))\n\n# autodiff?\nMeasurements.derivative(m.simdata.Pos[1].y.val, m.simdata.Mass[2].val)\n\nMeasurements.uncertainty_components(m.simdata.Pos[1].y.val)","category":"page"},{"location":"examples/03-Measurements/","page":"03 Measurements: Uncertainty propagation","title":"03 Measurements: Uncertainty propagation","text":"(Image: Uncertainty of elliptic orbit)","category":"page"},{"location":"examples/07-TDEcluster/#Tidal-Disruption-Event-(TDE)-of-Star-Cluster","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"","category":"section"},{"location":"examples/07-TDEcluster/","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"In this example, we demonstrate how to:","category":"page"},{"location":"examples/07-TDEcluster/","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"Define custom procedures to be executed in each time-step\nRemove accreted particles on the run\nWrite and visualize accretion history\nEstimate properties of the black hole","category":"page"},{"location":"examples/07-TDEcluster/","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"\nusing AstroNbodySim, PhysicalParticles\nusing Unitful, UnitfulAstro\nusing AstroIC\nusing AstroPlot\nusing DataFrames, CSV\nusing GLMakie\nastro()\nmkpathIfNotExist(\"output\")\n\nconstant = Constant(uAstro)\nG = constant.G\nc = constant.c\nMassBH = 1.0e8u\"Msun\"\n\nM = 1.0e6u\"Msun\" # mass of Plummer star cluster\nR = 0.01u\"kpc\"  # orbit radius at AP\n\nRg = r_g(G,MassBH,c)\n@show \"Schwarzchild radius: $(Rg)\"\n\n\n# Define the background force field of central black hole\n#! For distributed computing, use @everywhere\nfunction newtonAcc(p::AbstractParticle)\n    return - G * MassBH / (p.Pos * p.Pos) * ustrip(u\"kpc\", normalize(p.Pos))\nend\nbgforce = Function[newtonAcc]\n\n\n\"\"\"\n    accretion(sim::Simulation)\n\nIf the particle runs too close to the BH, delete it and append to accretion list.\n\"\"\"\nfunction accretion(sim::Simulation) # Direct Sum multi-threading on CPU\n    list = Int[]\n    pos = sim.simdata.Pos\n    for i in eachindex(pos)\n        if norm(pos[i]) <= 10000*Rg\n            push!(list, i)\n        end\n    end\n    StructArrays.foreachfield(v->deleteat!(v,list), sim.simdata)\n    return length(list)\nend\nanalysers = Dict(\n    \"accretion\" => accretion,\n)\n\n\n### TDE of star cluster with elliptic orbit\n\ne = 0.94 # eccentricity\n\nvel = sqrt((1.0-e)*G*MassBH/R)\n@info \"Velocity at ap: $(vel)\"\n\na = ellipticSemiMajor(G, MassBH, R, vel)\n@info \"Length of semi-major axis: $(a)\"\n\nT = ellipticPeriod(G, MassBH, a)\n@info \"Period of elliptical orbit: $(T)\"\n\npe = (1-e)/(1+e)*R\n@info \"pe orbit radius: $(pe)\"\n\n\nparticles = generate(PlummerStarCluster(\n        NumSamples = 400,\n        VirialRadius = 0.001u\"kpc\",\n        TotalMass = M,\n    ),\n    MaxRadius = 0.003u\"kpc\",\n);\n\nsetpos(particles, PVector(R, 0.0u\"kpc\", 0.0u\"kpc\"))\nsetvel(particles, PVector(0.0u\"kpc/Gyr\", vel, 0.0u\"kpc/Gyr\"))\n\n\nTimeEnd = T\nTimeBetweenSnapshots = T / 100\n\n\nelliptic = Simulation(\n    deepcopy(particles);\n    MinStep = 1.0e-11u\"Gyr\",\n    TimeEnd,\n    TimeBetweenSnapshots,\n    bgforce,\n    analysers,\n    OutputDir = \"output/TDE-elliptic\",\n    ForceSofteningTable = [0.05*suggest_softlen(particles) for i in 1:6],\n)\nrun(elliptic)\n\n\n### Plot\nL = ustrip(R)\nplot_positionslice(elliptic.config.output.dir, \"snapshot_\", collect(0:100), \".gadget2\", gadget2(),\n    dpi = 300, resolution = (600,600),\n    xlims = (-0.6L, +1.4L), ylims = (-L, +L),\n    times = collect(0:100) * TimeBetweenSnapshots,\n    markersize = 0.0001,\n)\nplt = mosaicview(elliptic.config.output.dir, \"pos_\", collect(1:9:100), \".png\"; fillvalue = 0.5, npad = 3, ncol = 4, rowmajor = true);\nsave(\"output/TDE-elliptic-mosaic.png\", plt)\n\n# Accretion history\ndf = DataFrame(CSV.File(joinpath(elliptic.config.output.dir, \"analysis.csv\")))\nN = similar(df.accretion)\nN[1] = df.accretion[1]\ns = N[1]\nfor i in 2:length(N)\n    @inbounds s += df.accretion[i]\n    @inbounds N[i] = s\nend\n@info \"Total particles accreated: $(N[end])\"\n\nfig = Figure(; resolution = (800, 450))\naxis = GLMakie.Axis(fig[1,1],\n    title = \"Total number of accreated particles\",\n    xlabel = \"t [Gyr]\",\n    ylabel = \"N\",\n)\nGLMakie.lines!(axis, df.time, N)\nMakie.save(\"output/TDE-elliptic-AccretionHistory.png\", fig)","category":"page"},{"location":"examples/07-TDEcluster/","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"(Image: TDE position slice mosaic view)","category":"page"},{"location":"examples/07-TDEcluster/","page":"07 Tidal Disruption Event (TDE) of Star Cluster","title":"07 Tidal Disruption Event (TDE) of Star Cluster","text":"(Image: TDE accretion history)","category":"page"},{"location":"citation/#CITATION","page":"CITATION","title":"CITATION","text":"","category":"section"},{"location":"citation/","page":"CITATION","title":"CITATION","text":"@arxiv","category":"page"},{"location":"examples/08-SolarSystem/#Solar-System","page":"08 Solar System","title":"08 Solar System","text":"","category":"section"},{"location":"examples/08-SolarSystem/","page":"08 Solar System","title":"08 Solar System","text":"using GLMakie\nusing AstroPlot\nusing PhysicalParticles, Unitful, UnitfulAstro\nusing AstroLib\nusing Dates\nusing ProgressMeter\n\nusing AstroIC\n\nfunction display_solarsystem(startdate = now(); fps = 60.0, N = 10000, ratio = 1.0, adapt = true)\n    last_plot_time = time()\n    time_between_plot = 1.0 / fps # ms\n\n    T = jdcnv(startdate)\n\n    fig = GLMakie.Figure()\n    \n    title = Observable(\"Solar System at \" * string(startdate))\n    ax = GLMakie.Axis(\n        f[1,1],\n        title = title,\n        xlabel = \"x [AU]\",\n        ylabel = \"z [AU]\",\n        aspect = AxisAspect(1.0),\n    )\n\n    ls = labelslider!(f, \"time ratio: \",  0.1:0.01:10.0)\n    ls.slider.value = ratio\n    f[2,1] = ls.layout\n\n    xu, yu = pack_xy(solarsystem(T), yaxis = :z)\n    x = ustrip.(u\"AU\", xu)\n    y = ustrip.(u\"AU\", yu)\n    if adapt\n        GLMakie.xlims!(ax, (middle(x) - 22, middle(x) + 22))\n        GLMakie.ylims!(ax, (middle(y) - 22, middle(y) + 22))\n    else\n        GLMakie.xlims!(ax, (-30, +30))\n        GLMakie.ylims!(ax, (-30, +30))\n    end\n\n    pos = Observable([x y])\n    GLMakie.scatter!(ax, pos, markersize = 5.0)\n    display(f)\n\n    @showprogress for i in 1:N\n        if time() - last_plot_time > time_between_plot\n            #T += to_value(sl1.value)\n            T += to_value(ls.slider.value)\n            \n            xu, yu = pack_xy(solarsystem(T), yaxis = :z)\n            x = ustrip.(u\"AU\", xu)\n            y = ustrip.(u\"AU\", yu)        \n            if adapt\n                GLMakie.xlims!(ax, (middle(x) - 22, middle(x) + 22))\n                GLMakie.ylims!(ax, (middle(y) - 22, middle(y) + 22))\n            end\n            @async title[] = \"Solar System at \" * string(daycnv(T))\n            @async pos[] = [x y]\n            last_plot_time = time()\n        end\n        sleep(0.1 / fps)\n    end\n    return fig\nend\n\ndisplay_solarsystem(adapt = false)","category":"page"},{"location":"examples/08-SolarSystem/","page":"08 Solar System","title":"08 Solar System","text":"(Image: Solar System)","category":"page"},{"location":"lib/Methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"lib/Methods/#Index","page":"Methods","title":"Index","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"Pages = [\"Methods.md\"]","category":"page"},{"location":"lib/Methods/#Public","page":"Methods","title":"Public","text":"","category":"section"},{"location":"lib/Methods/#Main-functions","page":"Methods","title":"Main functions","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"run\nstep\npreprocessdata\ncompute_force\ncompute_potential\noutput\nrestart\nsaverestart\nloadrestart\nsoftlen\nsuggest_softlen\nsuggest_softlen!\nset_softlen!","category":"page"},{"location":"lib/Methods/#Base.run","page":"Methods","title":"Base.run","text":"function run(sim::Simulation)\n\nThis function does all the work for you:\n\nprepare sim environment and preprocess data\nevaluate force, initialize timesteps, output\nmainloop\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.softlen","page":"Methods","title":"AstroNbodySim.softlen","text":"softlen(c::Collection, table::MVector)\nsoftlen(p::AbstractParticle, table::MVector)\nsoftlen(p::AbstractParticle, sim::Simulation)\nsoftlen(c::Collection, sim::Simulation)\n\nRetrive softening length from table\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.suggest_softlen","page":"Methods","title":"AstroNbodySim.suggest_softlen","text":"suggest_softlen(V::Number, N::Int64)\nsuggest_softlen(data::Union{Array, StructArray})\nsuggest_softlen(data::Union{Array, StructArray}, collection::Collection)\nsuggest_softlen(sim::Simulation)\n\nreturn recommended softening length\n\nSee also suggest_softlen! and set_softlen!\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.suggest_softlen!","page":"Methods","title":"AstroNbodySim.suggest_softlen!","text":"suggest_softlen!(sim::Simulation)\n\nSet all softening lengths to suggested value.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Particle-Mesh","page":"Methods","title":"Particle-Mesh","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"smooth_coef\ndiff_mat\ndiff_vec\ndelta_mat2\ndelta_mat3\nlaplace_conv_op\nlaplace_conv\nfft_poisson\nfft_poisson!\nfdm_poisson","category":"page"},{"location":"lib/Methods/#AstroNbodySim.smooth_coef","page":"Methods","title":"AstroNbodySim.smooth_coef","text":"smooth_coef(x_coord, fitting_order, diff_order)\n\nFit the data with fitting_order polynomial and calculate the diff_order differential at x=0. Input the x coordinates of data. Return the coefficients for calculating the result from data.\n\nSuppose the data is [u,v,w], we want to smooth v by fitting a line (1 order polynomial) and use it estimate a better v. Then set the x coordinates of [u,v,w] be [-1,0,1], fit it and calculate the result (0 order differential) at x=0, the result will be (u+v+w)/3. So smooth_coef([-1,0,1],1,0) will return [1/3,1/3/1/3].\n\nUsing Rational type or Sym type of SymPy can get the exact coefficients. For example, smooth_coef(Sym[0,1,2],2,1) get Sym[-3/2, 2, -1/2], which means the first order differential of [u,v,w] at u is -1.5u+2v-0.5w. Using this way can generate all data in https://en.wikipedia.org/wiki/Finite_difference_coefficient\n\nExamples\n\nLinear extrapolation: smooth_coef([1,2],1,0) get [2, -1], so the left linear extrapolation of [u,v] is 2u-v.\nQuadratic extrapolation: smooth_coef([-3,-2,-1],2,0) get [1, -3, 3], so the right Quadratic extrapolation of [u,v,w] is u-3v+3w.\nFirst order central differential: smooth_coef(Rational[-1,0,1],2,1) get [-1//2, 0//1, 1//2], so the first order differential of [u,v,w] at v is (w-u)/2\nSecond order central differential: smooth_coef([-1,0,1],2,2) get [1, -2, 1], so the second order differential of [u,v,w] at v is u+w-2v\nFive points quadratic smoothing: smooth_coef([-2,-1,0,1,2],2,0) get [-3/35, 12/35, 17/35, 12/35, -3/35], so [-3/35 12/35 17/35 12/35 -3/35]*[a,b,c,d,e] get the smoothed c.\nFour points quadratic interpolation: smooth_coef([-3,-1,1,3],2,0) get [-1/16, 9/16, 9/16, -1/16], so smooth_coef([-3,-1,1,3],2,0)'*[a,b,c,d] get the estimated value at the middle of b and c.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.diff_mat","page":"Methods","title":"AstroNbodySim.diff_mat","text":"diff_mat(n, order=1; T=Float64, dt=one(T), points=2*div(order+1,2)+1, lpoints=div(points,2), rpoints=points-lpoints-1, fitting_order=lpoints+rpoints, boundary=:Extrapolation, boundary_points=lpoints+rpoints+1, boundary_order=boundary_points-1, sparse=false)\n\nGenerate differential matrix.\n\nArguments\n\nn: Matrix size. If v is length n vector, diff_mat(n)*v calculate the differential of v.\norder: Differential order. \nT: Matrix element type. If set T=Rational or using SymPy and set T=Sym, diff_mat will return the exact value.\ndt: Numerical differential step size.\npoints: Number of points for fitting polynomial to estimate differential. This argument is only for convenience. The real number of points is always lpoints+rpoints+1.\nlpoints: Number of points at left to the target point, which differential is calculated by the fitted polynomial.\nrpoints: Number of points at right to the target point. If lpoints==rpoints, then the differential is estimated as central finite difference. If lpoints==0, then it is normal forward finite difference. If rpoints==0, then it is backward finite difference.\nfitting_order: The order of the fitted polynomial for estimating differential.\nboundary: Boundary condition. Can be Dirichlet()(boundary value is zero), Periodic(assume data is periodic), :Extrapolation(boundary value is extrapolated according to boundary_points and boundary_order), :None(not deal with boundary, will return non-square matrix).\nboundary_points: Number of points for fitting polynomial to estimate differential at boundary. Normally it should not be much less than points, otherwise sometimes the current point may not be used to estimate the differential.\nboundary_order: The order of the fitted polynomial for points determined by boundary_points.\nsparse: If true, return sparse matrix instead of dense one.\n\nExamples\n\nk=5; x=rand(k);\ndiff_mat(k,1;points=3)*x #do 3 points 1st order central differential ((x[n+1]-x[n-1])/2).\ndiff_mat(k,2;points=3)*x #do 3 points 2nd order central differential (x[n+1]+x[n-1]-2x[n]).\ndiff_mat(k,1;points=2,lpoints=0)*x #do the normal 1st order forward differential (x[n+1]-x[n]).\ndiff_mat(k,1;lpoints=1,rpoints=0)*x #do the 1st order backward differential (x[n-1]-x[n]).\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Machine-Learning","page":"Methods","title":"Machine Learning","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"train_cnn_poisson2d\ntrain_cnn_poisson3d\ncnn_poisson","category":"page"},{"location":"lib/Methods/#Timestep","page":"Methods","title":"Timestep","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"ConstantTimestep\nAdaptiveTimestep\ninit_timesteps\nfind_next_sync_point_and_drift\nadvance_and_find_timestep","category":"page"},{"location":"lib/Methods/#Energy","page":"Methods","title":"Energy","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"total_angular_momentum\ntotal_potential\ntotal_momentum\ntotal_kinetic\ntotal_energy","category":"page"},{"location":"lib/Methods/#AstroNbodySim.total_angular_momentum","page":"Methods","title":"AstroNbodySim.total_angular_momentum","text":"total_angular_momentum(sim::Simulation) -> Any\n\n\nCompute total angular momentum vector of the system\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.total_potential","page":"Methods","title":"AstroNbodySim.total_potential","text":"total_potential(data::StructArray) -> Any\n\n\nSum potential energy of particles in data. Potentials need to be computed in advance.\n\nReturn nothing if empty.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.total_momentum","page":"Methods","title":"AstroNbodySim.total_momentum","text":"total_momentum(sim::Simulation, axis::Symbol) -> Any\n\n\nCompute momentum of the system in the direction of axis\n\n\n\n\n\ntotal_momentum(sim::Simulation) -> Any\n\n\nCompute total momentum vector of the system\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.total_kinetic","page":"Methods","title":"AstroNbodySim.total_kinetic","text":"total_kinetic(data::StructArray) -> Any\n\n\nSum kinetic energy: 0.5 * data.Mass[i] * data.Vel[i] * data.Vel[i]\n\n\n\n\n\ntotal_kinetic(sim::Simulation) -> Any\n\n\nCompute kinetic energy of particles on workers and return the sum\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.total_energy","page":"Methods","title":"AstroNbodySim.total_energy","text":"total_energy(sim::Simulation) -> Any\n\n\nTotal energy (kinetic + potential) of sim data\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Data-processing","page":"Methods","title":"Data processing","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"find_particle\nsubstract_by_id\ndiff_by_id","category":"page"},{"location":"lib/Methods/#MOND","page":"Methods","title":"MOND","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"nu\nnu1\nnu2\nmond_Milgrom1983\nQUMOND_PDM_density\nQUMOND_phi\nQUMOND_acc\nQUMOND","category":"page"},{"location":"lib/Methods/#AstroNbodySim.nu","page":"Methods","title":"AstroNbodySim.nu","text":"nu(y::Number, n::Number = 2)\n\nGeneralized MOND (MOdified Newtonian Dynamics) interpolation function. See also nu1, nu2\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.nu1","page":"Methods","title":"AstroNbodySim.nu1","text":"nu1(y::Number)\n\nMOND (MOdified Newtonian Dynamics) interpolation function with index = 1. See also nu, nu2\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.nu2","page":"Methods","title":"AstroNbodySim.nu2","text":"nu1(y::Number)\n\nMOND (MOdified Newtonian Dynamics) interpolation function with index = 2. See also nu, nu1\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.mond_Milgrom1983","page":"Methods","title":"AstroNbodySim.mond_Milgrom1983","text":"mond_Milgrom1983(sim::Simulation, data::StructArray)\n\nApply Milgrom 1983 formula of MOND (MOdified Newtonian Dynamics) to accelerations\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.QUMOND_PDM_density","page":"Methods","title":"AstroNbodySim.QUMOND_PDM_density","text":"QUMOND_PDM_density(m::MeshCartesianStatic, ACC0::Number)\n\nCompute ρPDM on the RHS (right hand side) of QUMOND (QUasi-linear MOdified Newtonian Dynamics). Return ρPDM\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.QUMOND_phi","page":"Methods","title":"AstroNbodySim.QUMOND_phi","text":"QUMOND_phi(m::MeshCartesianStatic, ACC0::Number, G::Number)\n\nFirst compute ρ_PDM, then solve QUMOND (QUasi-linear MOdified Newtonian Dynamics) equation on the mesh. Return modified potential\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.QUMOND_acc","page":"Methods","title":"AstroNbodySim.QUMOND_acc","text":"QUMOND_acc(m::MeshCartesianStatic, ACC0::Number, G::Number)\n\nCompute ρ_PDM\nSolve modified potential on the mesh\nCompute acceleration by finite differencing the potential\n\nReturn acceleration\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.QUMOND","page":"Methods","title":"AstroNbodySim.QUMOND","text":"QUasi-linear MOdified Newtonian Dynamics\n\n\n\n\n\n","category":"type"},{"location":"lib/Methods/#Black-Hole","page":"Methods","title":"Black Hole","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"r_g\nradius_gravity\nradius_schwarzschild\npseudoNewtonianPotential\npseudoNewtonianAcc","category":"page"},{"location":"lib/Methods/#AstroNbodySim.r_g","page":"Methods","title":"AstroNbodySim.r_g","text":"r_g(G, M, c)\n\nr_g = 2 * G * M / c^2\n\nwhere G is the gravity constant, M is the mass of the central object, c is light speed.\n\nSchwarzchild radius.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.radius_gravity","page":"Methods","title":"AstroNbodySim.radius_gravity","text":"r_g(G, M, c)\n\nr_g = 2 * G * M / c^2\n\nwhere G is the gravity constant, M is the mass of the central object, c is light speed.\n\nSchwarzchild radius.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.radius_schwarzschild","page":"Methods","title":"AstroNbodySim.radius_schwarzschild","text":"r_g(G, M, c)\n\nr_g = 2 * G * M / c^2\n\nwhere G is the gravity constant, M is the mass of the central object, c is light speed.\n\nSchwarzchild radius.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.pseudoNewtonianPotential","page":"Methods","title":"AstroNbodySim.pseudoNewtonianPotential","text":"pseudoNewtonianPotential(G, M, c, R)\n\npot = - G * M / (R - r_g(G, M, c))\n\nPseudo-Newtonian potential around a compat central object. Diverge at gravity radius r_g.\n\n\n\n\n\npseudoNewtonianPotential(G, M, rg)\n\npot = - G * M / (R - rg)\n\nPseudo-Newtonian potential around a compat central object. Diverge at gravity radius r_g.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.pseudoNewtonianAcc","page":"Methods","title":"AstroNbodySim.pseudoNewtonianAcc","text":"pseudoNewtonianAcc(G, M, c, R, n::AbstractPoint)\n\nacc = - G * M / (R - r_g(G, M, c))^2 * n\n\nPseudo-Newtonian acceleration around a compat central object. Diverge at gravity radius r_g.\n\n\n\n\n\npseudoNewtonianAcc(G, M, c, R, n::AbstractPoint)\n\nacc = - G * M / (R - rg)^2 * n\n\nPseudo-Newtonian acceleration around a compat central object. Diverge at gravity radius r_g.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Elliptic-Orbit","page":"Methods","title":"Elliptic Orbit","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"ellipticSemiMajor\nellipticPeriod\neccentricity","category":"page"},{"location":"lib/Methods/#AstroNbodySim.ellipticSemiMajor","page":"Methods","title":"AstroNbodySim.ellipticSemiMajor","text":"ellipticSemiMajor(G::Number, M::Number, r::Number, v::Number) -> Any\n\n\nLength of semi-major axis of elliptic orbit\n\nG: gravitational constant\nM: mass of central object\nr: orbit radius at specific time\nv: velocity at radius r\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.ellipticPeriod","page":"Methods","title":"AstroNbodySim.ellipticPeriod","text":"ellipticPeriod(G::Number, M::Number, a::Number) -> Any\n\n\nOrbital period of elliptic orbit\n\nG: gravitational constant\nM: mass of central object\na: length of semi-major axis\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.eccentricity","page":"Methods","title":"AstroNbodySim.eccentricity","text":"eccentricity(G::Number, M::Number, v::Number, h::Number) -> Any\n\n\nEccentricity of elliptic orbit\n\nG: gravitational constant\nM: mass of central object\nv: velocity at radius r\nh: specific relative angular momentum at radius r\n\n\n\n\n\neccentricity(G::Number, M::Number, r::AbstractPoint, v::AbstractPoint) -> Any\n\n\nEccentricity vector of elliptic orbit\n\nG: gravitational constant\nM: mass of central object\nr: position at specific time\nv: velocity vector at position r\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Time-scales","page":"Methods","title":"Time scales","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"typicalvelocity\nmeandensity\ncrosstime\nhubbletime\nrelaxtime\ninteractiontime\ndynamicaltime\nfreefalltime\norbitaltime","category":"page"},{"location":"lib/Methods/#AstroNbodySim.typicalvelocity","page":"Methods","title":"AstroNbodySim.typicalvelocity","text":"typicalvelocity(G, M, R)\n\nv = sqrt(G*M/R)\n\nTypical velocity of a spherical system.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.meandensity","page":"Methods","title":"AstroNbodySim.meandensity","text":"meandensity(M, R)\n\nρ = 3*M/(4πR^3)\n\nMean density of a spherical system.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.crosstime","page":"Methods","title":"AstroNbodySim.crosstime","text":"crosstime(R, v)\n\nt_cross = R / v\n\nThe typical time needed to cross the system.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.hubbletime","page":"Methods","title":"AstroNbodySim.hubbletime","text":"hubbletime(H0)\n\nt_hubble = 1/H0\n\nThe age of the universe.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.relaxtime","page":"Methods","title":"AstroNbodySim.relaxtime","text":"relaxtime(R, v, N)\n\ntrelax = N/(10 lnN) tcross\n\nRelaxation time: The time over which the change in kinetic energy due to the long-range collisions has accumulated to a value that is comparable to the intrinsic kinetic energy of the particle.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.interactiontime","page":"Methods","title":"AstroNbodySim.interactiontime","text":"interactiontime(R, v, N)\n\nThe typical time between two short-range interactions that cause a change in kinetic energy comparable to the intrinsic kinetic energy of the particle.\n\ntinteraction = N * tcross\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.dynamicaltime","page":"Methods","title":"AstroNbodySim.dynamicaltime","text":"dynamicaltime(ρ, G)\n\nt_dyn = sqrt(3 * π / (16 * G * ρ))\n\nThe time required to travel halfway across the system.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.freefalltime","page":"Methods","title":"AstroNbodySim.freefalltime","text":"freefalltime(ρ, G)\n\nt_ff = sqrt(3 * π / (32 * G * ρ))\n\nThe time it takes a sphere with zero pressure to collapse to a point.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.orbitaltime","page":"Methods","title":"AstroNbodySim.orbitaltime","text":"orbitaltime(ρ, G)\n\nt_orb = sqrt(3π/(Gρ))\n\nThe time it takes to complete a (circular) orbit.\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Output-and-Logging","page":"Methods","title":"Output and Logging","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"outputparallel\nsetuploggers\nLogInfo\nDefaultTimer\nmkpathIfNotExist\ntraitstring","category":"page"},{"location":"lib/Methods/#AstroNbodySim.LogInfo","page":"Methods","title":"AstroNbodySim.LogInfo","text":"struct LogInfo\n\ntimers::Symbol\nTimer enum names to access timing (continuously starting from 1)\ntiming::Vector{UInt64}\nTimings defined by timer enums\nanalysers::Dict{String, Function}\nAnalyse on the whole simulation\n\nExamples #TODO\n\nUse uppercase letters to avoid\n\n\n\n\n\n\n\n","category":"type"},{"location":"lib/Methods/#AstroNbodySim.traitstring","page":"Methods","title":"AstroNbodySim.traitstring","text":"Better printing of trait types\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Tools","page":"Methods","title":"Tools","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"write_gadget2_makefile\nwrite_gadget2_param\nalter_param\nalter_line\nadd_line","category":"page"},{"location":"lib/Methods/#AstroNbodySim.write_gadget2_param","page":"Methods","title":"AstroNbodySim.write_gadget2_param","text":"function writegadget2param(filename::String, ICfilename::String)\n\nParams\n\nfilename   : name of param file\nICfilename : name of initial conditions\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.alter_param","page":"Methods","title":"AstroNbodySim.alter_param","text":"alter_param(filename::String, param::String, value)\n\nalter all lines containing param to param  value\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#AstroNbodySim.alter_line","page":"Methods","title":"AstroNbodySim.alter_line","text":"alter_line(filename::String, match::String, newline::String; all = false)\n\nalter the first line containing match to newline\n\nKeywords\n\nall::Bool = false : If true, alter all lines containing match to newline\n\n\n\n\n\n","category":"function"},{"location":"lib/Methods/#Internal","page":"Methods","title":"Internal","text":"","category":"section"},{"location":"lib/Methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"examples/06-GalaxyCollision/#Galaxy-Collision-(GPU)","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"","category":"section"},{"location":"examples/06-GalaxyCollision/","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"In this example, we demonstrate how to:","category":"page"},{"location":"examples/06-GalaxyCollision/","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"Accelerate computation with GPU\nCompute with Float32 (~10x faster on GPU than Float64)\nLoad Gadget-2 snapshot\nPlot position slices\nMosaic view of position slices","category":"page"},{"location":"examples/06-GalaxyCollision/","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"\nusing Unitful, UnitfulAstro\nusing Distributed\nusing PhysicalParticles\nusing AstroIC, AstroIO\nusing AstroNbodySim\nusing AstroPlot\nusing GLMakie\nusing Printf\n\nmkpathIfNotExist(\"output\")\n\n# The file is in the folder of examples/04-collisions\nheader, d = read_gadget2(joinpath(\"galaxy_littleendian.dat\"), uAstro, type=Star);  # 20000 disk and 40000 halo particles\n\n\nTimeEnd = 3.0f0u\"Gyr\"\nTimeBetweenSnapshots = 0.03f0u\"Gyr\"\n\ngpu = Simulation(\n    deepcopy(d);\n    floattype = Float32,\n    units = uAstro,\n    TimeEnd,\n    TimeBetweenSnapshots,\n    OutputDir = \"output/Collision-DirectSumAdaptiveGPU\",\n    constants = Constant(Float32, uAstro),\n    ZeroValues = ZeroValue(Float32, uAstro),\n    ForceSofteningTable = [0.4f0u\"kpc\" for i in 1:6],\n    Realtime = false,\n    device = GPU(),\n);\nrun(gpu)\n\n\n# Plot\nplot_positionslice(gpu.config.output.dir, \"snapshot_\", collect(0:100), \".gadget2\", gadget2(),\n    dpi = 300, resolution = (600,600),\n    xlims = (-200.0, +200.0), ylims = (-200.0, +200.0),\n    times = collect(0.0:0.03:3.0) * u\"Gyr\",\n    collection = DISK,\n    markersize = 2.0,\n)\nplt = mosaicview(gpu.config.output.dir, \"pos_\", collect(1:9:100), \".png\"; fillvalue = 0.5, npad = 3, ncol = 4, rowmajor = true);\nsave(\"output/mosaic-collision-DirectSumAdaptiveGPU.png\", plt)","category":"page"},{"location":"examples/06-GalaxyCollision/","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"(Image: Galaxy collision)","category":"page"},{"location":"examples/06-GalaxyCollision/","page":"06 Galaxy Collision (GPU)","title":"06 Galaxy Collision (GPU)","text":"(Image: Galaxy collision animation)","category":"page"},{"location":"examples/01-Binary/#Binary-orbit","page":"01 Binary orbit","title":"01 Binary orbit","text":"","category":"section"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"In this example, we demonstrate how to:","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"Output simulation information on the run\nEstimate properties of binary orbit and config the simulation\nManually generate binary stars\nPlot orbits with gapping\nAdd a background force field\nIntegrate elliptic orbits","category":"page"},{"location":"examples/01-Binary/#Circular-binary","page":"01 Binary orbit","title":"Circular binary","text":"","category":"section"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"using AstroIO\nusing AstroPlot\nusing AstroPlot.ColorSchemes\nusing Colors\nusing CSV, DataFrames\n\nusing Plots\npyplot() # Need PyPlot to be installed\n\nusing AstroNbodySim\nusing PhysicalParticles\nusing Unitful, UnitfulAstro\nastro()\nmkpathIfNotExist(\"output\")\n\nfunction plot_orbit_with_gap(sim::Simulation, title::String, gap::Int = 1; resolution = (800,800), kw...)\n    df = DataFrame(CSV.File(joinpath(sim.config.output.dir, \"analysis.csv\")))\n    x = df.x\n    y = df.y\n\n    title *= \" of every $(gap) orbit(s)\"\n    \n    count = 0\n    flip = 0\n    Head = 1\n    last_sign = sign(y[1])\n\n    plot_x = []\n    plot_y = []\n    for i in 1:length(y)\n        @inbounds new_sign = sign(y[i])\n        if new_sign != last_sign    # half cycle\n            flip += 1\n            last_sign = new_sign\n            \n            if flip % 2 == 0        # full cycle\n                count += 1\n                if count % gap == 0 # plot this cycle\n                    push!(plot_x, x[Head:i])\n                    push!(plot_y, y[Head:i])\n                    count = 0       # Reset gap\n                end\n                Head = i            # start of cycle\n            end\n        end\n        # do nothing\n    end\n\n    p = Plots.plot(plot_x, plot_y,\n        aspect_ratio = 1, legend = nothing, xlabel = \"x [kpc]\", ylabel = \"y [kpc]\",\n        size = resolution,\n    )\n    savefig(p, \"output/\" * title * \".png\")\n    @info \"Total orbits: $(div(flip, 2))\"\n    @info \"Steps per orbit: $(length(y) / div(flip, 2))\"\n    @info \"Figure has been saved to \" * title * \".png\"\n    return df\nend","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"analysers::Dict has full access to simulation data. The key values are functions that return one printable value, and they will be written in analysis.csv. Here we find one of the particle and output its x- and y- coordinates.","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"p1x(sim::Simulation) = find_particle(sim, 1).Pos.x\np1y(sim::Simulation) = find_particle(sim, 1).Pos.y\n\nanalysers = Dict(\n    \"x\" => p1x,\n    \"y\" => p1y,\n)","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"Now we estimate the orbit properties and set up the simulation","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"G = Constant(uAstro).G\nmass = 1.0e10u\"Msun\"\nD = 2.0u\"kpc\"\n\nbinary_orbit_period(mass, D) = 2 * pi * sqrt(0.5 * D^3 / G / mass)\n\nbinary_rot_vel(mass, D) = sqrt(G * mass / D / 2.0)\n\nvel = binary_rot_vel(mass, D)\nT = binary_orbit_period(mass, D)\n\n@info \"Estimated Period: $(T)\"\n@info \"Estimated Rotation Vel: $(vel)\"\n\n# Define the two particles\ndata = StructArray(Star(uAstro, id = i) for i in 1:2);\ndata.Pos[1] = PVector(+0.5D, 0.0u\"kpc\", 0.0u\"kpc\");\ndata.Pos[2] = PVector(-0.5D, 0.0u\"kpc\", 0.0u\"kpc\");\ndata.Vel[1] = PVector(0.0u\"kpc/Gyr\", +vel, 0.0u\"kpc/Gyr\");\ndata.Vel[2] = PVector(0.0u\"kpc/Gyr\", -vel, 0.0u\"kpc/Gyr\");\ndata.Mass .= mass;\n\n# Define simulations\nfunction compute_dt(a::Number; SofteningLength = 0.0001u\"kpc\", ErrTolTimestep = 0.025)\n    return sqrt(2 * ErrTolTimestep * SofteningLength / abs(a))\nend\n\nTimeStep = compute_dt(G*mass/D^2)\nTimeEnd = T * 1.01\nTimeBetweenSnapshots = TimeEnd\n\ncircular = Simulation(\n    deepcopy(data);\n    analysers,\n    TimeEnd,\n    TimeStep,\n    TimeBetweenSnapshots,\n    OutputDir = \"output/BinaryCircular\",\n);\nrun(circular)\nplot_orbit_with_gap(circular, \"Binary Circular\")","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"(Image: Binary Circular)","category":"page"},{"location":"examples/01-Binary/#Massless-circular-binary-with-background-force-field","page":"01 Binary orbit","title":"Massless circular binary with background force field","text":"","category":"section"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"mass = 0.5e10u\"Msun\"\nR = 1.0u\"kpc\"\n\nbinary_orbit_period(mass, R) = 2 * pi * sqrt(R^3 / G / mass)\nbinary_rot_vel(mass, R) = sqrt(G * mass / R)\n\nvel = binary_rot_vel(mass, R)\nT = binary_orbit_period(mass, R)\n\n@info \"Estimated Period: $(T)\"\n@info \"Estimated Rotation Vel: $(vel)\"\n\n# The only difference is that the particles have no mass, so they cannot produce any mutual forces\ndata = StructArray(Star(uAstro, id = i) for i in 1:2);\ndata.Pos[1] = PVector(+R, 0.0u\"kpc\", 0.0u\"kpc\");\ndata.Pos[2] = PVector(-R, 0.0u\"kpc\", 0.0u\"kpc\");\ndata.Vel[1] = PVector(0.0u\"kpc/Gyr\", +vel, 0.0u\"kpc/Gyr\");\ndata.Vel[2] = PVector(0.0u\"kpc/Gyr\", -vel, 0.0u\"kpc/Gyr\");\n\n# Define the background force field\nattractor(p::AbstractParticle) = -G * mass / (p.Pos * p.Pos) * normalize(p.Pos) / 1.0u\"kpc\"\nbgforce = Function[attractor]\n\nTimeEnd = T * 1.01\nTimeStep = compute_dt(G*mass/R^2)\nTimeBetweenSnapshots = TimeEnd\n\nbg = Simulation(\n    deepcopy(data);\n    bgforce,\n    analysers,\n    TimeEnd,\n    TimeStep,\n    TimeBetweenSnapshots,\n    OutputDir = \"output/bgforce\",\n);\nrun(bg)\nplot_orbit_with_gap(bg, \"Binary Circular with bgforce\")","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"(Image: Binary Circular in Background Force Field)","category":"page"},{"location":"examples/01-Binary/#Elliptic-orbit-precision","page":"01 Binary orbit","title":"Elliptic orbit precision","text":"","category":"section"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"R = 1.0u\"kpc\"\nmass = 1.0e8u\"Msun\"\n\ne = 0.9\n\nvel = sqrt((1.0-e)*G*mass/R)\n@info \"Velocity at ap: $(vel)\"\n\na = ellipticSemiMajor(G, mass, R, vel)\n@info \"Length of semi-major axis: $(a)\"\n\nT = ellipticPeriod(G, mass, a)\n@info \"Period of elliptical orbit: $(T)\"\n\ndata = StructArray(Star(uAstro, id = i) for i in 1:2)\ndata.Mass[2] = mass\n\ndata.Pos[1] = PVector(R, 0.0u\"kpc\", 0.0u\"kpc\")\ndata.Vel[1] = PVector(0.0u\"kpc/Gyr\", vel, 0.0u\"kpc/Gyr\")\n\n\nNumOrbits = 200\nTimeEnd = NumOrbits * T * 1.001\nTimeBetweenSnapshots = TimeEnd\n\n# Adaptive timesteps\nelliptic_adapt = Simulation(\n    deepcopy(data);\n    analysers,\n    TimeEnd,\n    ErrTolTimestep = 0.05,\n    TimeBetweenSnapshots,\n    ForceSofteningTable = [0.001u\"kpc\" for i in 1:6],\n    OutputDir = \"output/EllipticOrbitAdapt\",\n)\nrun(elliptic_adapt)\ndf = plot_orbit_with_gap(elliptic_adapt, \"Elliptic Orbit (adaptive)\", 40, resolution = (600,300))\n\n# Fixed timesteps\nΔt = df.time[2:end-1] .- df.time[1:end-2]\nelliptic_const = Simulation(\n    deepcopy(data);\n    analysers,\n    TimeEnd,\n    TimeStep = minimum(Δt) * u\"Gyr\",\n    ErrTolTimestep = 0.1,\n    TimeBetweenSnapshots,\n    ForceSofteningTable = [0.01u\"kpc\" for i in 1:6],\n    OutputDir = \"output/EllipticOrbitConst\",\n)\nrun(elliptic_const)\ndf = plot_orbit_with_gap(elliptic_const, \"Elliptic Orbit (const)\", 40, resolution = (600,300))","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"(Image: Elliptic Orbit with adaptive time-step)","category":"page"},{"location":"examples/01-Binary/","page":"01 Binary orbit","title":"01 Binary orbit","text":"(Image: Elliptic Orbit with constant time-step)","category":"page"},{"location":"#AstroNbodySim.jl","page":"Home","title":"AstroNbodySim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A年astrophysical simulation code library under GPL 3.0","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"]add AstroNbodySim","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/JuliaAstroSim/AstroNbodySim.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You might need to install NVIDIA CUDA toolkit","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute with units\nUser-friendly\nWell documented\nReadable programming\nVectorized array operations\nDispatch on types for various simulation settings\nFloat16, Float32, Float64, Int128, BigFloat, Measurement, etc.\nCross-platform: Linux, Windows, MacOS. Easy to deploy\nHybrid Parallelism: multi-threading, distributed parallelism, GPU acceleration\nModularity and Versatility: 10+ packages, designed for general purposes, highly extentable\nRealtime visualzation (interactive)\nAuto-test workflow","category":"page"},{"location":"#Development-Guide","page":"Home","title":"Development Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is highly recommended to use latest master branch of related packages (in JuliaAstroSim), first clone:\nParallelOperations.jl\nPhysicalParticles.jl\nAstroIO.jl\nAstroIC.jl\nPhysicalTrees.jl\nPhysicalMeshes.jl\nAstroPlot.jl\ndev --local [absolute path] to install packages mentioned above, for example\npkg> dev --local /home/user/work/AstroNbodySim\nVS Code as well as its Julia Extension is convenient to use, and Revise.jl will update changes on the run.","category":"page"},{"location":"#First-Time-User-Guide","page":"Home","title":"First Time User Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read documentation of Julia: https://docs.julialang.org/en/v1/\nRead documentations and READMEs of related packages\nTry examples in AstroNbodySim/examples. First install packages used in examples by AstroNbodySim/examples/install_pkgs.jl. The default output directory of all examples is ./output. The programme would make a directory if the user-defined output path does not exist to avoid unnecessary errors.\nTo interrupt a running simulation, create a file named stop in the output directory (same with Gadget2):\necho > output/stop\nIt's convenient to check out supported function arguments and keywords by help? in REPL, for example,\nhelp?> prepare\nsearch: prepare preprocessdata\n\n  function prepare(simulation::Simulation)\n\n  Do the following operations:\n  1. Say hello\n  2. Preprocess data\n  3. Check the output directory, make a new one if not exist\n  4. Remove \"stop\" file\n  5. Set the global preferred units\n  6. Set up logging, timing, profiling and analyzing log files","category":"page"},{"location":"#Supporting-and-Citing","page":"Home","title":"Supporting and Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This software was developed as part of academic research. If you would like to help support it, please star the repository. If you use this software as part of your research, teaching, or other activities, please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"%TODO WIP","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n]\nDepth = 1","category":"page"},{"location":"manual/DirectSum/#DirectSum","page":"DirectSum","title":"DirectSum","text":"","category":"section"}]
}
